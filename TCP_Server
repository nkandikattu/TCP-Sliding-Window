package server;

import java.net.*;
import java.io.*;
import java.util.*;

public class TCP_Server {

    // Initialize socket and input stream
    Socket sender = null;
    ServerSocket receiver;

    ObjectInputStream in;
    ObjectOutputStream out;

    int currSeqNum = -1023;
    int total_segments_received = 0;
    int total_segments_sent = 0;

    TreeSet<Integer> buffer = new TreeSet<>();
    ArrayList<String[]> seq_num_over_time = new ArrayList<>();
    ArrayList<Double> goodputs = new ArrayList<>();

    // Constructor
    public TCP_Server() {}

    //
    public void checkBuffer(int seqNum) throws IOException {
        // If buffer is empty, add sequence number to buffer
        // Send ACK for missing segment
        if(buffer.isEmpty()) {
            //System.out.println("Buffer is empty, adding " + seqNum + " to buffer." );
            buffer.add(seqNum);
            sendAck(currSeqNum + 1024);

            // If sequence number is the smallest missing number
        } else if(seqNum == buffer.first() - 1024) {

            // Create ArrayList for indexing
            ArrayList<Integer> bufferList = new ArrayList<>(buffer);

            // Check for sequence numbers in sequence starting with the original
            // Send ACKs for all that can be moved from the buffer
            for(int i = 0; i < bufferList.size(); i++) {
                if(seqNum == bufferList.get(0) - 1024) {
                    sendAck(seqNum + 1024);
                    seqNum = bufferList.get(0);
                    bufferList.remove(0);

                    currSeqNum = seqNum;
                }
            }

            // Replace old TreeSet with updated ArrayList
            buffer = new TreeSet<>(bufferList);

            // If sequence number comes after a missing sequence number, add to buffer
            // Send ACK for missing segment
        } else {
            buffer.add(seqNum);
            sendAck(currSeqNum + 1024);
        }
    }

    // Sends ACK for next expected sequence number
    public void sendAck(int ack) throws IOException {
        out.writeObject(ack);
        out.flush();
        System.out.println("Sent ACK of " + ack);
    }

    // Requests number of segments sent from client to calculate good-put
    public void requestSentSegmentNum() throws IOException {
        out.writeObject("How many segments sent so far?");
        out.flush();
        System.out.println("Number of segments sent requested from client.");
    }

    // Calculates goodput and average goodput
    public void calculateGoodput() {

        // Calculates goodput and adds to ArrayList
        double goodput = (double)total_segments_received/total_segments_sent;
        goodputs.add(goodput);

        // Calculates average goodput from ArrayList
        double goodputSum = 0;
        for(Double d: goodputs) {
            goodputSum += d;
        }
        double goodputAvg = goodputSum/goodputs.size();

        System.out.println("Total segments received: " + total_segments_received);
        System.out.println("Total segments sent: " + total_segments_sent);
        System.out.println("Goodput for " + total_segments_received + " segments: " + goodput);
        System.out.println("Average Goodput: " + goodputAvg);
        System.out.println();
    }

    // All actions associated with receiving packets
    public void receivePackets() throws ClassNotFoundException, SocketException {

        // Start of execution time
        long startTime = System.nanoTime();

        // True while client is sending segments
        boolean keepListening = true;
        while(keepListening) {

            try {
                // Reads Object
                Object segment = in.readObject();

                if (segment instanceof String) {
                    String segments_sent = (String) segment;
                    total_segments_sent = Integer.parseInt(segments_sent);
                    calculateGoodput();

                } else {
                    int seqNum = (int) segment;
                    System.out.println("Message received: " + seqNum);

                    total_segments_received++;
                    System.out.println("Total segments received: " + total_segments_received);
                    if(total_segments_received % 1000 == 0) {
                        requestSentSegmentNum();
                    }

                    long endTime = System.nanoTime();
                    seq_num_over_time.add(new String[]{String.valueOf(seqNum), String.valueOf(startTime - endTime)});

                    if (buffer.isEmpty() && seqNum == currSeqNum + 1024) {
                        if(seqNum == 64513) {
                            sendAck(1);
                            currSeqNum = -1023;
                        } else {
                            sendAck(seqNum + 1024);
                            currSeqNum = seqNum;
                        }
                    } else if (seqNum < currSeqNum) {
                        System.out.println("Duplicate segment sent with sequence number: " + seqNum + ". Discarded");
                    } else {
                        System.out.println("Loss detected. checkBuffer() called.");
                        checkBuffer(seqNum);
                    }

                    System.out.println();
                }
            } catch (EOFException e) {
                System.out.println("Nothing left to receive.");
                keepListening = false;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    public void run() {

        try {

            // Instantiate server
            receiver = new ServerSocket(9999);
            System.out.println("TCP_Server established: " + receiver.getInetAddress());

            // Establish connection with Client
            System.out.println("\nWaiting for a client ...");
            sender = receiver.accept();
            System.out.println("Client accepted.");
            System.out.println("Connection established with: " + sender.getInetAddress());

            // Takes in input from client socket and gives output
            in = new ObjectInputStream(sender.getInputStream());
            out = new ObjectOutputStream(sender.getOutputStream());

            // Handshake in form of receiving "network" and sending "success"
            String msg = (String)in.readObject();
            System.out.println("\nMessage received: " + msg);
            if(msg.equals("network")) {
                out.writeObject("success");
                out.flush();
                System.out.println("Connection tested successfully.");
            }

            receivePackets();

            // Close I/O streams and server.
            in.close();
            out.close();
            receiver.close();
            System.out.println("\nConnection Terminated.");

        } catch(ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SocketException e) {
            System.out.println("Connection Refused.");
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String args[]) throws IOException, InterruptedException {
        TCP_Server server = new TCP_Server();
        server.run();
    }
}
